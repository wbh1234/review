<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!--定义一个对象-->
<script>
    var obj = {//对象直接量
        name:'list',
        age:19
    };
    var obj1 = new Object();//实例化
    obj1.name = "zhangsan";

    //类：具有相同属性和方法的对象的集合
//    var fn = function(){
//        console.log('my name is ' + this.name);
//    }

    function Person(name) {
//        this.name = name;
//        this.sayHello = fn;
//        this.sayHello = function () {
//            console.log('my name is' + this.name);
//        }
    }
    Person.prototype.name ='lisi';
    Person.prototype.father = {
        name:'zbuff'
    }
    Person.prototype.sayHello = function(){
        console.log('my name is '+ this.name);
    }

    var person1 = new Person('zhangsan');
    var person2 = new Person('lisi');


    person1.father.name = 'kkkkk';
    person1.name = 'jjjj';
    console.log(person1.name);//person1.name属于栈内存，各自有自己的属性不共用
    console.log(person2.name);
    console.log(person1.father.name);
    console.log(person2.father.name);
//属性要写在构造函数中，方法要写在prototype中
//
//    person1.sayHello();
//    person2.sayHello();

    //原型:原型是用来继承的，每次new一个实例对象的时候，实例对象就会有原型下所有的东西
    //原型链:是一个查找的过成，访问对象下的一个方法或者属性的时候，他会到构造函数中查找
    //构造函数中没有，回去下边的原型中查找，没有会去父类中找 一直向上找，找到object 如果没有返回undefind


//    继承
    function A(){
        this.name = 'zhangsan';
        this.hobby = ['dance','sing'];
    }
    A.prototype.say = function(){
        console.log('hello');
    };
    function B(){
        A.call(this);//this输出B,this指向obj
//        A.call继承属性
    }
    B.prototype = new A();//B.prototype.name='zhangsan'
//    prototype继承方法

    var oB1 = new B();
    var oB2 = new B();
    B.prototype.constructor = B;
    console.log(oB1.constructor);
//    constructor是构造函数，是prototype下的属性

//    oB1.hobby.push('shopping');
//
//    console.log(oB2.hobby);





























</script>
</body>
</html>